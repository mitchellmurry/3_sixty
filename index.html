<!DOCTYPE html>
<html lang="en">
  <head>
    <title>3_Sixty Animation</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      body {
        background-color: #ffffff;
        margin: 0px;
        overflow: hidden;
      }

      a {
        color:#0078ff;
      }
    </style>
  </head>
  <body>

    <script src="js/three.min.js"></script>
    <script src="js/libs/dat.gui.min.js"></script>
    <script src="js/libs/stats.min.js"></script>

    <script src="js/controls/OrbitControls.js"></script>
    <script src="js/renderers/Projector.js"></script>
    <script src="js/renderers/CanvasRenderer.js"></script>

    <script>
var renderer, scene, camera, controls, particle;
var guiControls, datGUI;
var particles = []
var speeds = []
var meshs = []

var settings = {
  particleCount: 6,
  tubeMinSpeed: 0.005,
  tubeMaxSpeed: 0.01,
  tubeThickness: 0.5,
  tubeArcMin: Math.PI / 6,
  tubeArcMax: Math.PI / 3,
  tubeRadiusMin: 10,
  tubeRadiusMax: 20,
  color1: "#009ee3", 
  color2: "#dedc00", 
  color3: "#e94e1c",
  color4: "#009ee3", 
  color5: "#dedc00", 
  color6: "#e94e1c",
}

//dat gut
var gui = new dat.GUI();

gui.add(settings, 'particleCount', 1, 20).step(1).onFinishChange(function (value) {
  init()
});

gui.add(settings, 'tubeMinSpeed', 0, 0.02).onFinishChange(function (value) {
  init()
});

gui.add(settings, 'tubeMaxSpeed', 0, 0.1).onFinishChange(function (value) {
  init()
});

gui.add(settings, 'tubeThickness', 0.1, 2).onFinishChange(function (value) {
  init()
});

gui.add(settings, 'tubeArcMin', 0, 1).onFinishChange(function (value) {
  init()
});

gui.add(settings, 'tubeArcMax', 0.05, 2).onFinishChange(function (value) {
  init()
});

gui.add(settings, 'tubeRadiusMin', 2, 20).onFinishChange(function (value) {
  init()
});

gui.add(settings, 'tubeRadiusMax', 4, 40).onFinishChange(function (value) {
  init()
});

gui.addColor(settings, 'color1').onFinishChange(function (value) {
  init()
});
gui.addColor(settings, 'color2').onFinishChange(function (value) {
  init()
});
gui.addColor(settings, 'color3').onFinishChange(function (value) {
  init()
});
gui.addColor(settings, 'color4').onFinishChange(function (value) {
  init()
});
gui.addColor(settings, 'color5').onFinishChange(function (value) {
  init()
});
gui.addColor(settings, 'color6').onFinishChange(function (value) {
  init()
});

renderer = new THREE.WebGLRenderer( { antialias: true } );
renderer.setPixelRatio( window.devicePixelRatio );
renderer.setSize( window.innerWidth, window.innerHeight );
renderer.setClearColor(0xffffff, 1)
document.body.appendChild( renderer.domElement );

init();

function init() {
  // empty each time we init (in case we change anything in the sliders)
  paths = []
  speeds = []
  colors = [settings.color1, settings.color2, settings.color3, settings.color4, settings.color5, settings.color6].filter(function (item) {
    return item !== null
  })
  
  // scene
  scene = new THREE.Scene();

  while(scene.children.length > 0){ 
    scene.remove(scene.children[0]); 
  }
  
  // camera
  camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
  camera.position.set(0, 0, 60);
  
  controls = new THREE.OrbitControls( camera );
  controls.minDistance = 10;
  controls.maxDistance = 100;  
  
  var map = new THREE.TextureLoader().load( "360logo.svg" );
  var material = new THREE.SpriteMaterial( { map: map, color: 0xffffff, fog: false } );
  var sprite = new THREE.Sprite(material);
  var size = 50
  sprite.scale.set(size, size * 0.5, 0)
  scene.add(sprite);

  for (var i = 0; i < settings.particleCount; i++) {
    function Ellipse(rad, e) {
      THREE.Curve.call(this);
      this.radius = rad
      this.end = e
    }

    Ellipse.prototype = Object.create( THREE.Curve.prototype );
    Ellipse.prototype.constructor = Ellipse;

    // define the getPoint function for the subClass
    Ellipse.prototype.getPoint = function ( t ) {
      var radians = this.end * t;

      return new THREE.Vector3(this.radius * Math.cos( radians ),
                               this.radius * Math.sin( radians ),
                               0);
    };
    
    var path = new THREE.Group();   
    
    var color = colors[i % colors.length]
    var material = new THREE.MeshBasicMaterial({ color: color });
    
    var radius = settings.tubeRadiusMin + (Math.random() * (settings.tubeRadiusMax - settings.tubeRadiusMin))
    var rotation = new THREE.Vector3(
      2 * Math.PI * Math.random(), 
      2 * Math.PI * Math.random(), 
      0
    )
      
    var arc = settings.tubeArcMin + (Math.random() * (settings.tubeArcMax - settings.tubeArcMin))

    var geometry = new THREE.TubeGeometry(
      new Ellipse(radius, arc), 
      100, 
      settings.tubeThickness, 
      20, 
      false
    );
    var mesh = new THREE.Mesh(geometry, material);
    
    var startBall = new THREE.SphereGeometry(settings.tubeThickness, 32, 32);
    var startBallMesh = new THREE.Mesh(startBall, material);
    startBallMesh.position.x = radius

    var endBall = new THREE.SphereGeometry(settings.tubeThickness, 32, 32);
    var endBallMesh = new THREE.Mesh(endBall, material);
    endBallMesh.position.x = radius * Math.cos(arc)
    endBallMesh.position.y = radius * Math.sin(arc)

    path.add(mesh)
    path.add(startBallMesh)
    path.add(endBallMesh)

    path.rotation.x = rotation.x;
    path.rotation.y = rotation.y;
      
    var speed = new THREE.Vector3(
      0, 
      0, 
      settings.tubeMinSpeed + (Math.random() * (settings.tubeMaxSpeed - settings.tubeMinSpeed))
    )
      
      scene.add(path);
      
      paths.push(path)
      speeds.push(speed)
    }   
    
    animate();
  }
  
  function animate() {
    requestAnimationFrame( animate );

    for (var i = 0; i < paths.length; i++) {
      // get the group from the particles array
      var path = paths[i]
      
      // get the speed of rotation from the speeds array
      var speed = speeds[i]
      
      path.rotation.x += speed.x;
      path.rotation.y += speed.y;
      path.rotation.z += speed.z;
      
    }

    renderer.render( scene, camera );
  }

    </script>
  </body>
</html>